# HTTP0.9 vs HTTP1.0 vs HTTP1.1 vs HTTP2.0 vs HTTP3.0
## 概述
**HTTP**（HyperText Transfer Protocol）是万维网（World Wide Web）基础的协议，自 Tim Berners-Lee 博士和他的团队在1989-1991年间创造。随着互联网日益的发展，HTTP已经发生了很多变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个实验室交换文件的早期协议进化成了可以传输图片，高分辨率视频和3D效果的现代复杂互联网协议。下面我们从HTTP的版本迭代过程中介绍HTTP的进化之路。

## HTTP/0.9 – 单行协议
最初的HTTP协议是没有版本的，后来为了区分其它版本，将最初的HTTP协议版本号定为0.9。

HTTP0.9非常简单，请求由单行指令构成，以唯一可用的方法 `GET` 开头，紧跟着的是请求资源的路径。下面是一个例子：
```
GET /mypage.html
```

响应也非常简单，只包含响应文档本身: 
```html
<HTML>
这是一个非常简单的HTML页面
</HTML>
```

跟1.0相比，0.9简单到没有响应头，这也意味着它只能传递唯一的文件类型：HTML，也没有响应的状态码或者错误码，一旦出错，也只返回一个特殊的描述问题的HTML文档。

## HTTP/1.0 – 构建可扩展性
由于HTTP0.9过于简单，无法满足大多数需求，所以浏览器和服务器扩展了0.9的内容使其用途更广。HTTP1.0追加的内容如下：
- 协议版本信息被追加到 `GET` 请求行的末尾 。
- 服务器响应的时候发送状态码，使浏览器能知道请求执行的状态是成功或者失败，并调整其相应的行为（如更新或者使用本地缓存）。
- 引入HTTP头的概念，无论是请求还是相应，允许传输元数据，使协议更加灵活和可扩展。
- 由于HTTP头的引入，使其拥有可以传输除纯文本以外的其它类型文件的能力，指明文件类型的头为：`Content-Type`

以下是一个HTTP1.0完整请求的例子：
```http
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML> 
一个包含图片的页面
  <IMG SRC="/myimage.gif">
</HTML>
```

但是这些扩展只是一种尝试，并没有真正纳入标准。虽然RFC 1945定义了HTTP1.0，但是它是狭义的，并不是官方标准。

## HTTP/1.1 – 标准化的协议
由于HTTP1.0不是标准，所以很多不同的实现和扩展方式是比较混乱的。自1995年开始，即HTTP/1.0文档发布的下一年，就开始修订HTTP的第一个标准化版本。在1997年初，HTTP1.1 标准发布。

HTTP/1.1 消除了大量歧义内容并引入了多项改进：
- 连接可以复用，节省了多次打开TCP连接加载网页内容的时间。
- 增加管线化技术，允许在第一个请求被完全应答之前就可以发送第二个请求，以降低通信延迟。
- 支持响应分块。
- 引入额外的缓存机制。
- 引入内容协商机制，包括语言、编码、类型等，允许客户端和服务端之间约定以最合适的内容进行交换。
- 引入 `Host` 头部，能够使不同域名配置在同一个IP地址的服务器上。

## 超过15年的扩展
由于HTTP协议的可扩展性，创建新的头部和方法是很容易的。即使HTTP/1.1协议进行过两次修订，RFC 2616 发布于1999年6月，而另外两个文档 RFC 7230-RFC 7235 发布于2014年6月，作为HTTP/2的预览版本，HTTP协议已经稳定使用超过15年了。

## HTTP的安全传输
HTTP最大的变化在1994年底，HTTP在基本的TCP/IP协议栈上发送信息，网景公司（Netscape Communication）在此基础上创建了一个额外的加密传输层：SSL。目前HTTPS已经基本是标配，它保证了通信过程的安全。关于 `SSL` 的具体介绍，可以查看我的另一篇文章[SSL/TLS握手详解](./HTTP/../tsl-protocol-intro.md)。

## HTTP/2 - 为了更优异的表现
随着互联网的发展，网页变得越来越复杂，甚至演变成了应用。可见媒体的播放量和脚本的交互量也增加了许多，更多的内容和数据通过HTTP传输。HTTP/1.1链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（一般是5到8个），但是带来的成本和复杂性堪忧。比如，HTTP管线化（pipelining）就成为了Web开发的负担。

在2010年到2015年，谷歌通过实践了一个实验性的SPDY协议，证明了客户端和服务器交互数据的另一种方式。其解决了一定的浏览器和服务器之间的交换数据的焦点问题，解决了复杂数据的传输和增加了响应数量，SPDY成为了HTTP/2协议的基础。

HTTP/2在HTTP/1.1有几处基本的不同：
- HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，增加传输效率。
- 多路复用，并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
- 头部压缩，因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
- 支持服务器推送数据，不再依赖客户端的主动请求。

在2015年5月正式标准化后，HTTP/2取得了极大的成功，在2016年7月前，8.7%的站点已经在使用它，代表超过68%的请求。

## 后HTTP/2进化
随着HTTP2的发布，它的进化没有停止，HTTP的扩展性依然可以用来增加新的功能。其它新的扩展：
- 对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。
- `Client Hint` 的引入允许浏览器来主动交流它的需求，或者将硬件的约束发给服务端。
- 在Cookie头中引入安全相关的前缀，保证Cookie不被篡改。

HTTP每一次进化证实了它良好的扩展性和简易性，释放了很多应用程序的创造力并且情愿使用这个协议。

## 更进一步，还在路上的HTTP/3
虽然HTTP/2的多路复用，可以提高一定的通信效率，但是也带来了副作用。多个HTTP流使用同一个TCP连接，遵守同一个流量状态控制，只要第一个HTTP流遭遇到拥塞，剩下的HTTP流压根没法发出去，这就是头部阻塞（Head of line Blocking）。

既然TCP不好用，那为何要吊死在TCP这一棵树上呢？

于是HTTP/3选择了QUICK协议。它Google开发的一个协议，QUIC协议集成了TCP可靠传输机制、TLS安全加密、HTTP /2 流量复用技术，其页面的加载时间为2.5 RTT时间。

此外，完成QUIC交易的连接的Session ID会缓存在浏览器内存里，如果用户再次打开该页面，无需建立TLS连接，直接使用缓存Session ID 对应的加密参数，服务器可以根据Session ID在缓存里查找对应的加密参数，并完成加密。

虽然HTTPP/3还在路上，但是未来可期。