# http缓存
通过复用之前的获取的资源，可以显著提高网站和应用程序的性能。使用缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。

## 不同类型的缓存
缓存是一种保存资源副本并在资源没有更新时，直接使用副本资源的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的副本，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。但是我们要合理配置缓存，因为资源不是一层不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。

缓存的种类有很多，可以大概分为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用，私有缓存只能用于单独用户。

#### 私有缓存（浏览器缓存）
私有缓存一般作用域单独的用户，在浏览器中就有单独的”缓存“设置选项。浏览器缓存用户通过HTTP下载的所有文档，这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。

#### 共享缓存（代理服务器缓存）
共享缓存可以给多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

### 缓存操作的目标
虽然 HTTP 缓存不是必须的，但是近几年随着Web的发展，需要传输的静态资源越来越丰富，所以缓存也变得越来越受推崇。常见的 HTTP 缓存只能存储 `GET` 响应，对于其他的响应无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。下面是一些常见的缓存案例：
- 一个包含例如HTML文档，图片，或者文件的成功响应，响应码为200 ok。
- 永久重定向: 响应状态码：301。
- 错误响应: 响应状态码：404 的一个页面。
- 不完全的响应: 响应状态码 206，只返回局部的信息。
- 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应。

### 缓存控制
#### 强缓存
HTTP/1.1 允许定义 `Cache-Control` 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个数据，通过设置不同的属性值定义不同的缓存策略。

**无缓存**

缓存中不存储关于客户端请求和服务端响应的任何内容，每次客户端发起的请求，都去从服务端重新下载。
```
Cache-Control: no-store
```

**缓存但重新验证**

设置如下属性：
```
Cache-Control: no-cache
```

每次有请求发出时，缓存会将请求发送到服务器，询问服务器请求中的内容是否过期，若未过期，则使用本地缓存的副本。

**私有和共享缓存**

设置 `public` 属性值表示可以该响应内容可以被任何中间人（例如代理服务器、CDN）缓存，而 `private` 则表示该响应是专用于某单个用户的浏览器，中间人不能缓存此响应。
```
Cache-Control: private
Cache-Control: public
```

**过期**

可以通过设置 `max-age=$seconds` 来表示资源能够被缓存的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。

```
Cache-Control: max-age=31536000
```

**验证方式**
当使用了 "must-revalidate" 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态。

```
Cache-Control: must-revalidate
```

**Pragma**
Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。

### 协商缓存
由于浏览器只有有限的空间用来存储缓存资源，所以缓存会定期删除一些副本。另一方面，服务器上的资源也会更新，所以缓存中的资源也需要被更新，所以双方就需要根据一定的规则约定过期时间。

**Last-Modified和If-Modified-Since**

对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的头，相应的缓存的寿命就是N。通常情况下，如果不含含这个属性的请求则会去查看是否包含 Expires 属性，通过比较 Expires 的值和头里面 Date 属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息，如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以以10，也就是乘以10%。

Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会进行计算对比，如果缓存没有失效，则命中协商缓存。

**Etag和If None Match**

Etag是上一次加载资源时，服务器返回的对该资源的唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。

**Etag vs Last-Modified**

1.在精度上，ETag要优于Last-Modified。Last-Modifed的时间单位是秒，如果某个文件在1秒内修改了很多次，那么他们的Last-Modified其实没有体现出来修改，但是ETag每次都会改变确保了精度，如果是负载均衡的服务器，各个服务器生成的Last-Modified也可能不一致。

2.在性能上，ETag要逊于Last-Mdified，毕竟Last-Modified只需要记录时间，而Etag需要通过算法计算出来一个hash值。

3.最后在优先级上，服务器优先考虑ETag。